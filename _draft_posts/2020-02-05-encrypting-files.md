---
layout: post
title: Encrypting Files With a User Generated Password
snippet: Using AES encryption and pbkdf2 hashing to protect users files
tags: [encryption, AES, pbkdf2, cryptography]
---

There are many approaches to encrypting files using a password generated by a user and today I will be discussing one option. This post details how you can securly store the ecryption keys for a file inside that very file without degrading cryptographic integrity of that file's encryption. 

## Theoretical Approach

Suppose we take a password from a user denoted ``p``

## Implmentation
In order to run this implementation you need the python library ``cryptography``
You can install it using pip: ``pip install cryptography``

### Generation and Encryption of Keys
```python
import os
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

def generate_key_and_file_header():
	password = input("Enter a password: ")
	salt = os.urandom(16)
	kdf = PBKDF2HMAC(
				algorithm=hashes.SHA256(),
				length=64,
				salt=salt,
				iterations=1000000,
				backend=default_backend()
			)
	hashed_pass = kdf.derive(password)

	aes_key = hashed_pass[:32]
	hash_authentication = hashed_pass[32:]

	aes_key = os.urandom(32) #Use this key to encrypt the file
	iv = os.urandom(16)

	cipher = Cipher(algorithms.AES(hashed_pass[:32]), modes.CBC(iv), backend=default_backend())
	encryptor = cipher.encryptor()
	encypted_aes_key = encryptor.update(aes_key) + encryptor.finalize()

	# This header can be prepended to the encrypted file
	# and will not make the encryption insecure
	secure_file_header = salt + hash_authentication + encypted_aes_key + iv

	return (aes_key, secure_file_header)

```

### Decryption of Keys

```python
def decrypt_keys(secure_file_header):
	#file header length = 112 bytes 
	salt = file_header[:32] # 32 bytes 
	hash_authentication = file_header[32:64] #32 bytes 
	encrypted_aes_key = file_header[64:96] #32 bytes
	iv = file_header[96:] #16 bytes
	
	password = input("Enter a password: ")
	kdf = PBKDF2HMAC(
			algorithm=hashes.SHA256(),
			length=64,
			salt=salt,
			iterations=1000000,
			backend=default_backend()
		)
	hashed_pass = kdf.derive(password)
	
	if( hashed_pass[32:] != hash_authentication):
		print("Incorrect Password...")
		return
	
	cipher = Cipher(algorithms.AES(hashed_pass[:32]), modes.CBC(iv), backend=default_backend())
	decryptor = cipher.decryptor()
	aes_key = decryptor.update(encrypted_aes_key) + decryptor.finalize()
	
	return aes_key
```